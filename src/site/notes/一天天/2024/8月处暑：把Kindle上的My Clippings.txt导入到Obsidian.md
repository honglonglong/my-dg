---
{"dg-publish":true,"permalink":"//2024/8-kindle-my-clippings-txt-obsidian/","tags":["æŠ€æœ¯ç ”ç©¶"],"created":"2024-08-31T17:29:40.365+08:00"}
---

æœ€è¿‘åœ¨å®Œå–„è‡ªå·±çš„ç”Ÿæ´»å·¥ä½œæµï¼Œå…¶ä¸­ä¸€é¡¹æ˜¯çœ‹å®Œä¹¦æŠŠç¬”è®°å­˜åˆ°obsidianï¼Œä¸ºåç»­æ¶ˆåŒ–æ•´ç†åšå‡†å¤‡ã€‚

ç°æœ‰çš„å·¥å…·è¯•è¿‡ä¸‹é¢è¿™äº›ï¼Œéƒ½ä¸èƒ½æ»¡è¶³æˆ‘çš„è¦æ±‚ï¼ˆå¦‚å®è¡¨è¾¾ï¼Œæ„Ÿæ©åšå‡ºçš„è´¡çŒ®ï¼‰ï¼š
1. ä¸èƒ½åœ¨ipad obsidianä¸Šè¿è¡Œ (Kindle Highlights)
2. å¯¼å…¥æ ¼å¼æŒºå¥½çœ‹ï¼Œä¹Ÿç»™äº†æˆ‘å¯å‘ï¼Œä½†æ˜¯æ ‡è®°ä½ç½®ä»€ä¹ˆçš„éƒ½æ²¡äº† ï¼Œä¸è¿‡å¯ä»¥åšä¸ºå¤‡ç”¨ï¼ˆKindle Highlight Importer from HTML)
3. ä¸¢æ•°æ® (memo.bookfere.com)
4. å¯¼å‡ºå¤ªå¤šå°±æ”¶è´¹ï¼ˆclippings.ioï¼‰
5. å¤ªå­¤ç«‹ä¸èƒ½å­˜åˆ°obsidian ï¼ˆklib appï¼‰

ä¸‹é¢çš„è¿‡ç¨‹å®Œå…¨ä¾é moonshot kimiåŠ©æ‰‹ï¼Œå³ä½¿æœ¬äººæ˜¯ç¨‹åºå‘˜ï¼Œä½†è¦èŠ±æ—¶é—´å»ç ”ç©¶apiä¹Ÿå¾ˆå¤´ç–¼ï¼Œäºæ˜¯å…ˆé AIèµ·æ‰‹ï¼Œæ²¡æƒ³åˆ°å®ƒå®Œæˆçš„éå¸¸å‡ºè‰²ï¼Œæˆ‘åªå¾®è°ƒäº†ä¸€äº›bugå’Œæ˜¾ç¤ºä¸Šçš„ä¸è¶³ã€‚

è€—æ—¶å°†è¿‘4å°æ—¶ï¼Œè¿™è¦æ˜¯è®©æˆ‘è‡ªå·±å†™ä¸çŸ¥é“è¦ç”¨å¤šé•¿æ—¶é—´ã€‚

ç‚¹å‡»é“¾æ¥æŸ¥çœ‹å’Œ Kimi æ™ºèƒ½åŠ©æ‰‹çš„å¯¹è¯ https://kimi.moonshot.cn/share/cr9eebmgi3pu4dp0437g

ä¸‹é¢çš„æ€»ç»“ä¹Ÿæ˜¯è®©AIå®ƒè‡ªå·±å¼„çš„ï¼š
> åœ¨è¿™ä¸ªå¯¹è¯ä¸­ï¼Œæˆ‘ä»¬è®¨è®ºäº†å¦‚ä½•ä½¿ç”¨ Obsidian çš„ `runjs` æ’ä»¶æ¥å¤„ç† Kindle çš„ `My Clippings.txt` æ–‡ä»¶ï¼Œå¹¶å°†å…¶å†…å®¹è½¬æ¢ä¸º Markdown æ ¼å¼ã€‚ä»¥ä¸‹æ˜¯å¯¹è¯çš„ä¸»è¦è¦ç‚¹ï¼š
> 
> 1. **è§£ææ–‡ä»¶å†…å®¹**ï¼šç¼–å†™äº†ä¸€ä¸ª JavaScript å‡½æ•° `parseClippings` æ¥è§£æ `My Clippings.txt` æ–‡ä»¶ï¼Œæå–ä¹¦ç±æ ‡é¢˜ã€æ—¥æœŸã€æ‘˜å½•ç±»å‹ï¼ˆæ ‡æ³¨æˆ–ç¬”è®°ï¼‰ã€é¡µç ä½ç½®å’Œæ‘˜å½•æ–‡æœ¬ã€‚
> 
> 2. **ç»„ç»‡ç¬”è®°å’Œæ ‡æ³¨**ï¼šåˆ›å»ºäº†ä¸€ä¸ªå‡½æ•° `organizeClippings`ï¼Œç”¨äºå°†ç¬”è®°ï¼ˆå¦‚æœå®ƒä»¬æ²¡æœ‰é™„åŠ åˆ°ä»»ä½•æ ‡æ³¨ï¼‰ç»„ç»‡åˆ°æ ‡æ³¨ä¸‹ã€‚ç¬”è®°å¦‚æœæ²¡æœ‰æ‰¾åˆ°ç›¸åº”çš„æ ‡æ³¨ï¼Œåˆ™ä½œä¸ºç‹¬ç«‹çš„æ¡ç›®ä¿ç•™ã€‚
> 
> 3. **å†™å…¥ Markdown æ–‡ä»¶**ï¼šç¼–å†™äº†ä¸€ä¸ªå‡½æ•° `writeMarkdown`ï¼Œå°†è§£æå’Œç»„ç»‡åçš„å†…å®¹å†™å…¥æ–°çš„ Markdown æ–‡ä»¶ã€‚æ ‡æ³¨ä½¿ç”¨å¼•ç”¨æ ¼å¼ï¼Œç¬”è®°ç›´æ¥æ˜¾ç¤ºåœ¨æ ‡æ³¨å†…å®¹ä¹‹ä¸‹ã€‚ç‹¬ç«‹çš„ç¬”è®°ä¹ŸæŒ‰ç…§ä¸€å®šçš„æ ¼å¼è¾“å‡ºã€‚
> 
> 4. **æ–‡ä»¶é€‰æ‹©**ï¼šè®¨è®ºäº†å¦‚ä½•åœ¨ iPad ä¸Šä½¿ç”¨ Obsidian æ—¶é€‰æ‹©æ–‡ä»¶ã€‚ç”±äº `runjs` æ’ä»¶ä¸ç›´æ¥æ”¯æŒå¼¹å‡ºé€‰æ‹©å™¨ï¼Œå»ºè®®å°†æ–‡ä»¶é¢„å…ˆæ”¾ç½®åœ¨ Obsidian çš„åº“ä¸­ï¼Œå¹¶åœ¨è„šæœ¬ä¸­ç›´æ¥æŒ‡å®šæ–‡ä»¶è·¯å¾„ã€‚
> 
> 5. **é”™è¯¯å¤„ç†å’Œæ—¥å¿—è®°å½•**ï¼šåœ¨ä»£ç ä¸­æ·»åŠ äº†é”™è¯¯å¤„ç†å’Œæ—¥å¿—è®°å½•ï¼Œä»¥å¸®åŠ©è°ƒè¯•å’Œè·Ÿè¸ªä»£ç æ‰§è¡Œè¿‡ç¨‹ã€‚
> 
> 6. **ä»£ç æ‰§è¡Œ**ï¼šæä¾›äº†ä¸€ä¸ªä¸»å‡½æ•° `main` æ¥ä¸²è”æ•´ä¸ªæµç¨‹ï¼ŒåŒ…æ‹¬è¯»å–æ–‡ä»¶ã€è§£æå†…å®¹ã€ç»„ç»‡æ‘˜å½•å’Œå†™å…¥æ–‡ä»¶ã€‚
> 
> 7. **æ–‡ä»¶è·¯å¾„**ï¼šå¼ºè°ƒäº†åœ¨å®é™…ä½¿ç”¨ä¸­éœ€è¦å°†æ–‡ä»¶è·¯å¾„æ›¿æ¢ä¸ºå®é™…çš„ `My Clippings.txt` æ–‡ä»¶è·¯å¾„ã€‚
> 
> è¿™ä¸ªå¯¹è¯å±•ç¤ºäº†å¦‚ä½•ä½¿ç”¨ `runjs` æ’ä»¶æ¥è‡ªåŠ¨åŒ–å¤„ç†å’Œè½¬æ¢ Kindle æ‘˜å½•çš„è¿‡ç¨‹ï¼Œä»¥åŠå¦‚ä½•é€šè¿‡ Obsidian ç®¡ç†è¿™äº›ä¿¡æ¯ã€‚

æ¥ä¸‹æ¥æˆ‘è¦åšçš„æ˜¯æŠŠä»kindle appï¼ŒiBooké‡Œçš„ç¬”è®°ï¼Œè½¬åŒ–æˆmarkdownå¹¶ä¿å­˜åˆ°obsidianä¸­ï¼Œä¸è¿‡è¿™ä¸ªä¸æ€¥äº†ï¼Œå› ä¸ºæš‚æ—¶ç”¨ä¸ä¸Šï¼Œæ—¶é—´å…¨ç”¨æ¥åšè¿™ä¸ªåå€’æ²¡æ—¶é—´çœ‹ä¹¦äº†ã€‚

æœ€ç»ˆçš„ä»£ç ä¾›å‚è€ƒï¼š

```js RunJS_removeme="{n:'Book/Import Kindle Clippings1', t:'s'}"

// å¼•å…¥Obsidiançš„API
import * as obsidian from 'obsidian';
const RunJS = this; // ç”¨äºrunjsæ’ä»¶ä¸­çš„æ—¥å¿—è®°å½•

// è¯»å–My Clippings.txtæ–‡ä»¶
async function readMyClippings(filePath) {
  // RunJS.log(`Attempting to read My Clippings from: ${filePath}`);
  try {
    const content = await RunJS.app.vault.adapter.read(filePath);
    // RunJS.log(`Successfully read My Clippings file, length=${content.length}`);
    return content;
  } catch (error) {
    RunJS.log(`Failed to read My Clippings file: ${error}`);
    throw error;
  }
}

// è§£æMy Clippings.txtæ–‡ä»¶å†…å®¹
async function parseClippings(content) {
  // RunJS.log(`Parsing clippings content...`);
  const clippings = content.split(/==========/);
  //RunJS.log(`Number of clippings: ${clippings.length}`);
  const books = {};

  clippings.forEach(clipping => {
    if (clipping.trim() !== '') {
      const lines = clipping.trim().split('\n');
      // RunJS.log(`Number of lines: ${lines.length}`);
      const bookTitle = lines[0].trim();
      // RunJS.log(`Lines[0]: ${bookTitle}`);
      const bookDetails = lines[1].trim();
      // RunJS.log(`Lines[1]: ${bookDetails}`);
      
      const date = bookDetails.match(/æ·»åŠ äº (.*)/)[1];
      const type = bookDetails.includes('çš„æ ‡æ³¨') ? 'Highlight' : 'Note';
      const positionMatch = bookDetails.match(/ä½ç½® #(\d+)(-(\d+))?/);
      const pageMatch = bookDetails.match(/æ‚¨åœ¨ç¬¬ (\d+) é¡µ/);//ç¬¬ 19 é¡µ
      const page = {
        startPos: positionMatch[1],
        num: pageMatch[1]
      };
      if (positionMatch[3]) {
        page.endPos = positionMatch[3];
      }
      //const page = bookDetails.match(/ä½ç½® #(\d+)/) ? `Page: ${bookDetails.match(/ä½ç½® #(\d+)/)[1]}` : '';
      const text = lines.slice(3).join('\n').trim();
      //RunJS.log(`lines.slice(3).join('\n').trim(): ${text}`);
      const clippingInfo = {
        title: bookTitle,
        date: date,
        type: type,
        page: page,
        text: text,
        notes: [] // åˆå§‹åŒ–ç¬”è®°æ•°ç»„
      };

      if (!books[bookTitle]) {
        books[bookTitle] = [];
        //RunJS.log(`Found new book: ${bookTitle}`);
      }

      books[bookTitle].push(clippingInfo);
      //RunJS.log(`Parsed clipping for: ${bookTitle}`);
    }
  });

  //RunJS.log(`Finished parsing clippings.`);
  return books;
}

function organizeClippings(books) {
  for (const [bookTitle, clippings] of Object.entries(books)) {
    // å…ˆå­˜å‚¨æ‰€æœ‰æ ‡æ³¨çš„å¼•ç”¨
    const highlights = clippings.filter(clipping => clipping.type === 'Highlight');
    // å†å¤„ç†ç¬”è®°ï¼Œå°è¯•æ‰¾åˆ°å¯¹åº”çš„æ ‡æ³¨
    for (let i = 0; i < clippings.length; i++) {
      const note = clippings[i];
      if (note.type === 'Note') {
        let attached = false;
        for (const highlight of highlights) {
          if (note.page.startPos >= highlight.page.startPos && (!highlight.page.endPos || note.page.startPos <= highlight.page.endPos)) {
            highlight.notes = highlight.notes || [];
            highlight.notes.push(note);
            attached = true;
            break;
          }
        }
        if (!attached) {
          // å¦‚æœç¬”è®°æ²¡æœ‰é™„åŠ åˆ°ä»»ä½•æ ‡æ³¨ï¼Œä¿ç•™ä¸ºç‹¬ç«‹ç¬”è®°
          note.standAlone = true;
        }
      }
    }
  }
}

// å°†è§£æåçš„å†…å®¹å†™å…¥æ–°çš„Markdownæ–‡ä»¶
async function writeMarkdown(books, targetFolder) {
  //RunJS.log(`Writing clippings to Markdown files...`);
  for (const [bookTitle, clippings] of Object.entries(books)) {
    //const markdownContent = clippings.join('\n\n');
    const markdownContent = [];
    for (const clipping of clippings) {
      if (clipping.type === 'Highlight') {
        // å¤„ç†æ ‡æ³¨
        markdownContent.push(`### æ ‡æ³¨ï¼Œç¬¬${clipping.page.num}é¡µï¼Œä½ç½®  ${clipping.page.startPos}${clipping.page.endPos ? `-${clipping.page.endPos}\n` : '\n'}`);
        markdownContent.push(`\n> ${clipping.text}\n\n`);
        // å¤„ç†é™„åŠ åˆ°æ ‡æ³¨çš„ç¬”è®°
        if (clipping.notes && clipping.notes.length > 0) {
        markdownContent.push(`> [!ç¬”è®°]\n`);
        for (const note of clipping.notes) {
            markdownContent.push(`> ${note.text}\n`);
          }
        }
        markdownContent.push('\n---\n');
      } else if (clipping.type === 'Note' && clipping.standAlone) {
        // å¤„ç†ç‹¬ç«‹ç¬”è®°
        markdownContent.push(`### ç¬”è®°ï¼Œç¬¬${clipping.page.num}é¡µï¼Œä½ç½® ${clipping.page.startPos}\n`);
        markdownContent.push(`\n>[!${clipping.text}]\n\n---\n`);
      }
    }

    const markdownPlainContent = markdownContent.join('');
    const targetPath = `${targetFolder}/${bookTitle.replace(/\s+/g, '_')}.md`;
    try {
	  let file = RunJS.app.vault.getAbstractFileByPath(targetPath);
	  if(file === null) {
		  //RunJS.log("File not exists, create");
		  await RunJS.app.vault.create(targetPath, markdownPlainContent);
	  } else {
		  //RunJS.log("File exists, modify");
		  await RunJS.app.vault.modify(file, markdownPlainContent);
	  }
      
      //RunJS.log(`Successfully created Markdown file: ${targetPath}`);
    } catch (error) {
      RunJS.log(`Error creating Markdown file for ${bookTitle}: ${error}`);
    }
  }
  //RunJS.log(`Finished writing Markdown files.`);
}

async function main()
{ // ç«‹å³æ‰§è¡Œçš„å¼‚æ­¥å‡½æ•°
  try {
    //RunJS.log("Start");
	const myClippingsPath = '1 ğŸ“¥æ”¶é›†ç®±/ğŸ“šè¯»ä¹¦å¿ƒå¾—/Kindle/My Clippings.txt'; // æ›¿æ¢ä¸ºä½ çš„My Clippings.txtæ–‡ä»¶è·¯å¾„
	const targetFolder = '1 ğŸ“¥æ”¶é›†ç®±/ğŸ“šè¯»ä¹¦å¿ƒå¾—/Kindle'; // æ›¿æ¢ä¸ºä½ æƒ³è¦åˆ›å»ºMarkdownæ–‡ä»¶çš„ç›®æ ‡æ–‡ä»¶å¤¹è·¯å¾„

    //RunJS.log(`Starting the process...`);
    
    // è¯»å–My Clippings.txtæ–‡ä»¶
    const content = await readMyClippings(myClippingsPath);
    //RunJS.log(`Successfully read My Clippings file.`);
    
    // è§£æMy Clippings.txtæ–‡ä»¶å†…å®¹
    const books = await parseClippings(content);
    organizeClippings(books); // æ–°å¢ç»„ç»‡æ‘˜å½•çš„æ­¥éª¤
    // å°†è§£æåçš„å†…å®¹å†™å…¥æ–°çš„Markdownæ–‡ä»¶
    await writeMarkdown(books, targetFolder);
    //RunJS.log(`Process completed successfully.`);
  } catch (error) {
    RunJS.log(`An error occurred during the process: ${error}`);
  }
};

main().then().catch(RunJS.log);
```


<div class="transclusion internal-embed is-loaded"><a class="markdown-embed-link" href="///" aria-label="Open link"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-link"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a><div class="markdown-embed">




*æœ¬ç«™æ‰€æœ‰å†…å®¹ç‰ˆæƒåŠè§£é‡Šæƒå½’æœ¬ç«™å†…å®¹å‘å¸ƒè€…ï¼ˆå¤è‡³å¤•é˜³ï¼‰æ‰€æœ‰ï¼Œå¦‚éœ€è½¬è½½è¯·æ³¨æ˜å‡ºå¤„å¹¶é™„ä¸Šæœ¬ç«™é“¾æ¥ï¼Œå¦‚æœ‰ä¾µæƒè¯·è”ç³»ã€‚*


</div></div>
